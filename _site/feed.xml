<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-10-07T16:01:59+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">안기환</title><subtitle>프론트엔드 개발자</subtitle><entry><title type="html">일곱 난쟁이 - 백준 문제풀이</title><link href="http://localhost:4000/algorithm/2024/10/07/%EC%9D%BC%EA%B3%B1-%EB%82%9C%EC%9F%81%EC%9D%B4-%EB%B0%B1%EC%A4%80-%EB%AC%B8%EC%A0%9C.html" rel="alternate" type="text/html" title="일곱 난쟁이 - 백준 문제풀이" /><published>2024-10-07T12:12:00+09:00</published><updated>2024-10-07T12:12:00+09:00</updated><id>http://localhost:4000/algorithm/2024/10/07/%EC%9D%BC%EA%B3%B1%20%EB%82%9C%EC%9F%81%EC%9D%B4-%EB%B0%B1%EC%A4%80%20%EB%AC%B8%EC%A0%9C</id><content type="html" xml:base="http://localhost:4000/algorithm/2024/10/07/%EC%9D%BC%EA%B3%B1-%EB%82%9C%EC%9F%81%EC%9D%B4-%EB%B0%B1%EC%A4%80-%EB%AC%B8%EC%A0%9C.html"><![CDATA[<h1 id="목차">목차</h1>
<ul>
  <li><a href="#문제">문제</a></li>
  <li><a href="#내가-생각한-포인트">내가 생각한 포인트</a></li>
  <li><a href="#나의-과정">나의 과정</a></li>
  <li><a href="#추가-신경쓸-부분">추가 신경쓸 부분</a></li>
  <li><a href="#나의-코드">나의 코드</a></li>
</ul>

<h1 id="문제">문제</h1>

<blockquote>
  <p><a href="https://www.acmicpc.net/problem/2309">백준 문제 - 일곱 난쟁이(2309)</a></p>
</blockquote>

<details>

<summary>
문제 내용 보기
</summary>

문제 <br />
<br />
왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다. 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.<br />
아홉 명의 난쟁이는 모두 자신이 "백설 공주와 일곱 난쟁이"의 주인공이라고 주장했다. 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.<br />
아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.
<br /><br />
입력 <br />
<br />
아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다. 주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.<br />
<br />
출력 <br />
<br />
일곱 난쟁이의 키를 오름차순으로 출력한다. 일곱 난쟁이를 찾을 수 없는 경우는 없다.
</details>
<p><br /></p>

<h1 id="내가-생각한-포인트">내가 생각한 포인트</h1>

<ol>
  <li>키의 합이 100</li>
  <li>7명</li>
  <li>오름차순 출력</li>
</ol>

<h1 id="나의-과정">나의 과정</h1>

<p>나는 <code class="language-plaintext highlighter-rouge">7명</code>과 <code class="language-plaintext highlighter-rouge">합이 100</code>이라는 점을 생각하여 <code class="language-plaintext highlighter-rouge">slice()</code>를 이용하여 7명을 맞추고 <code class="language-plaintext highlighter-rouge">reduce()</code>를 이용해서 그 합이 100이 되는 것을 찾으려고 했다. 하지만 문제는 <code class="language-plaintext highlighter-rouge">랜덤으로 7명이 아닌 고정된 값으로 7명</code>을 찾으려고 했으니 실패를 하였다.</p>

<p>그래서 문제를 조금 다르게 접근해 봤다. 9명 중 7명만 포함이니 이중 for문으로 두명의 합이 받은 input값의 합에서 100을 뺀 값이랑 같으면 두 수를 저장하고 input에서 두 수를 제외한 배열에 sort()를 통해 오름차순 출력을 해주면 정답이 되었다.</p>

<h1 id="추가-신경쓸-부분">추가 신경쓸 부분</h1>
<p>데이터 타입도 신경을 써줘야 했다. 당연히 숫자 타입이라고 생각했는데 문자 타입으로 출력되어 불필요한 시간을 소요했다.</p>

<h1 id="나의-코드">나의 코드</h1>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nf">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">shortPerson</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nf">readFileSync</span><span class="p">(</span><span class="dl">'</span><span class="s1">/dev/stdin</span><span class="dl">'</span><span class="p">).</span><span class="nf">toString</span><span class="p">().</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="se">\n</span><span class="dl">'</span><span class="p">);</span> 

<span class="kd">const</span> <span class="nx">limit</span> <span class="o">=</span> <span class="mi">100</span>

<span class="c1">// 받은 input의 합에서 100을 뺀 값</span>
<span class="kd">const</span> <span class="nx">totalMinlimit</span> <span class="o">=</span> <span class="p">(</span><span class="nx">shortPerson</span><span class="p">.</span><span class="nf">reduce</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">cur</span><span class="p">)</span><span class="o">=&gt;</span> <span class="nx">acc</span> <span class="o">+</span> <span class="nc">Number</span><span class="p">(</span><span class="nx">cur</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="nx">limit</span>

<span class="kd">let</span> <span class="nx">remove</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1">// 이중 for문으로 두 수의 합이 totalMinlimit인 것을 찾는 코드</span>
<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">shortPerson</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">iShortPerson</span> <span class="o">=</span> <span class="nc">Number</span><span class="p">(</span><span class="nx">shortPerson</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">shortPerson</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">jShortPerson</span> <span class="o">=</span> <span class="nc">Number</span><span class="p">(</span><span class="nx">shortPerson</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">iShortPerson</span> <span class="o">+</span> <span class="nx">jShortPerson</span> <span class="o">===</span> <span class="nx">totalMinlimit</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">remove</span> <span class="o">=</span> <span class="p">[</span><span class="nx">iShortPerson</span><span class="p">,</span> <span class="nx">jShortPerson</span><span class="p">]</span>
      <span class="k">break</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 찾은 두수를 제외한 값과 sort()를 통한 내림차순 구현</span>
<span class="kd">const</span> <span class="nx">answer</span> <span class="o">=</span> <span class="nx">shortPerson</span><span class="p">.</span><span class="nf">filter</span><span class="p">((</span><span class="nx">person</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nx">remove</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="nc">Number</span><span class="p">(</span><span class="nx">person</span><span class="p">))).</span><span class="nf">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="o">-</span><span class="nx">b</span><span class="p">)</span>

<span class="nx">answer</span><span class="p">.</span><span class="nf">forEach</span><span class="p">((</span><span class="nx">num</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="algorithm" /><summary type="html"><![CDATA[목차 문제 내가 생각한 포인트 나의 과정 추가 신경쓸 부분 나의 코드]]></summary></entry><entry><title type="html">Nest.js에서 fetch 캐시하기 with App-Router</title><link href="http://localhost:4000/next.js/2024/10/03/Nest.js%EC%97%90%EC%84%9C-fetch-%EC%BA%90%EC%8B%9C%ED%95%98%EA%B8%B0-with-App-Router.html" rel="alternate" type="text/html" title="Nest.js에서 fetch 캐시하기 with App-Router" /><published>2024-10-03T21:12:45+09:00</published><updated>2024-10-03T21:12:45+09:00</updated><id>http://localhost:4000/next.js/2024/10/03/Nest.js%EC%97%90%EC%84%9C%20fetch%20%EC%BA%90%EC%8B%9C%ED%95%98%EA%B8%B0%20with%20App-Router</id><content type="html" xml:base="http://localhost:4000/next.js/2024/10/03/Nest.js%EC%97%90%EC%84%9C-fetch-%EC%BA%90%EC%8B%9C%ED%95%98%EA%B8%B0-with-App-Router.html"><![CDATA[<h1 id="목차">목차</h1>
<hr />

<ul>
  <li><a href="#일반-fetch-vs-nextjs-fetch">일반 fetch() vs Next.js fetch()</a></li>
  <li><a href="#nextjs의-fetch-옵션">Next.js의 fetch() 옵션</a>
    <ul>
      <li><a href="#cache할-경우">cache할 경우</a></li>
      <li><a href="#cache하지-않는-경우">cache하지 않는 경우</a></li>
      <li><a href="#특정-시간-이후에-다시-fetch">특정 시간 이후에 다시 fetch</a></li>
      <li><a href="#특정-요청이-들어-왔을-때에-다시-fetch">특정 요청이 들어 왔을 때에 다시 fetch</a></li>
    </ul>
  </li>
  <li><a href="#request-memoization">Request Memoization</a></li>
</ul>

<h1 id="일반-fetch-vs-nextjs-fetch">일반 fetch() vs Next.js fetch()</h1>
<hr />

<p>Next.js에서는 fetch()함수로 데이터를 통신하는 것을 권장한다. 이 이유는 Next.js 기존 fetch의 확장판으로 커스텀 했기 때문이다. 일반 fetch와는 다르게 Next.js의 fetch()는 캐싱 및 성능 최적화 기능을 더해준다. 어떠한 기능이 있는지 살펴보자.</p>

<h1 id="nextjs에서-fetch를-logging하는-법">Next.js에서 fetch를 logging하는 법</h1>
<hr />

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** @type {import('next').NextConfig} */</span>
<span class="kd">const</span> <span class="nx">nextConfig</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">logging</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">fetches</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">fullUrl</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">nextConfig</span><span class="p">;</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">next.config.mjs</code>파일에 위와 같이 <code class="language-plaintext highlighter-rouge">logging</code>옵션을 추가해 주면 터미널에서 확인 할 수 있다.</p>

<h1 id="nextjs의-fetch-옵션">Next.js의 fetch() 옵션</h1>
<hr />

<h2 id="cache할-경우">cache할 경우</h2>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://api.vercel.app/blog</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">cache</span><span class="p">:</span> <span class="dl">'</span><span class="s1">force-cach</span><span class="dl">'</span> <span class="p">})</span>
</code></pre></div></div>
<p>요청의 결과를 저장하는 옵션이다. 첫 요청을 제외하고는 위와 같이 fetch()가 있어도 통신을 하지 않고 저장된 데이터 값을 가져온다. 거의 변하지 않는 데이터를 렌더링할 때 사용하면 좋은 옵션이다.</p>

<h2 id="cache하지-않는-경우">cache하지 않는 경우</h2>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://api.vercel.app/blog</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">cache</span><span class="p">:</span> <span class="dl">'</span><span class="s1">no-store</span><span class="dl">'</span> <span class="p">})</span>
</code></pre></div></div>
<p>요청의 결과를 저장하지 않는 옵션이다. <code class="language-plaintext highlighter-rouge">{ cache: 'no-store' }</code>를 두번째 인자에 넣어주면 된다. 이러면 페이지 진입할 때마다 fetch()를 진행한다. 실시간성 데이터가 렌더링 될 때 사용하면 적합한 옵션이다.<br />
옵션의 기본 값으로 옵션에 아무런 설정을 하지 않으면 <code class="language-plaintext highlighter-rouge">{ cache: 'no-store' }</code>처럼 동작한다.<br />
<strong>(* v15이전 버전은 캐싱하는 것을 기본으로 설정되었으나 사용자가의 불만이 많아 v15부터는 캐싱하지 않는 것이 default이다.)</strong></p>

<h2 id="특정-시간-이후에-다시-fetch">특정 시간 이후에 다시 fetch</h2>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://api.vercel.app/blog</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">next</span><span class="p">:</span> <span class="p">{</span> <span class="na">revalidate</span><span class="p">:</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">})</span>
</code></pre></div></div>

<p>Page-Router의 ISR과 같이 특정 시간을 주기로 캐시를 업데이트 하는 방식이다. 가끔 데이터가 업데이트 될 때 사용하면 적합한 옵션이다. revalidate안에 들어갈 숫자는 초단위이다.</p>

<h2 id="특정-요청이-들어-왔을-때에-다시-fetch">특정 요청이 들어 왔을 때에 다시 fetch</h2>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://api.vercel.app/blog</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">next</span><span class="p">:</span> <span class="p">{</span> <span class="na">tags</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">]}})</span>
</code></pre></div></div>
<p>Page-Router의 On-Demand ISR과 비슷한 방식이다. 처음 요청 시 데이터를 캐시하고, 특정 요청 시 있을 때 갈아끼우는 형식이다. 가끔 변하는 데이터를 핸들링할 때 편리한 옵션이다.</p>

<h1 id="request-memoization">Request Memoization</h1>
<hr />

<p>Next.js에는 여러 컴포넌트의 모음이다. 만약 각 컴포넌트에 동일 fetch가 있다고 가정하면 어떻게 될까?<br /></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">AComponent</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://api.vercel.app/blog</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">cache</span><span class="p">:</span> <span class="dl">'</span><span class="s1">no-store</span><span class="dl">'</span> <span class="p">})</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">BComponent</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://api.vercel.app/blog</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">cache</span><span class="p">:</span> <span class="dl">'</span><span class="s1">no-store</span><span class="dl">'</span> <span class="p">})</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">CComponent</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://api.vercel.app/blog</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">cache</span><span class="p">:</span> <span class="dl">'</span><span class="s1">no-store</span><span class="dl">'</span> <span class="p">})</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">Page</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return </span><span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">AComponent</span><span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="nx">BComponent</span><span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="nx">CComponent</span><span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Next.js에서는 이러한 경우 모든 fetch를 요청하는 것이 아닌 하나의 요청만 캐시하고 나머지는 캐시된 데이터를 전달한다. 이것은 위에서 보았던 fetch의 캐시 영역이랑은 조금 별개의 영역이다. fetch()에서 제공하는 것이 아닌 Next.js에서 제공해주는 최적화이다. <br />
이렇게 렌더링이 끝나면 fetch cache와는 다르게 데이터는 보관하지 않고 사라진다.</p>]]></content><author><name></name></author><category term="Next.js" /><summary type="html"><![CDATA[목차]]></summary></entry><entry><title type="html">리액트 컴포넌트는 왜 대문자로 시작해야 하는가?</title><link href="http://localhost:4000/react/2024/09/30/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%8A%94-%EC%99%9C-%EB%8C%80%EB%AC%B8%EC%9E%90%EB%A1%9C-%EC%8B%9C%EC%9E%91%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80.html" rel="alternate" type="text/html" title="리액트 컴포넌트는 왜 대문자로 시작해야 하는가?" /><published>2024-09-30T21:23:45+09:00</published><updated>2024-09-30T21:23:45+09:00</updated><id>http://localhost:4000/react/2024/09/30/%EB%A6%AC%EC%95%A1%ED%8A%B8%20%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%8A%94%20%EC%99%9C%20%EB%8C%80%EB%AC%B8%EC%9E%90%EB%A1%9C%20%EC%8B%9C%EC%9E%91%ED%95%B4%EC%95%BC%20%ED%95%98%EB%8A%94%EA%B0%80</id><content type="html" xml:base="http://localhost:4000/react/2024/09/30/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%8A%94-%EC%99%9C-%EB%8C%80%EB%AC%B8%EC%9E%90%EB%A1%9C-%EC%8B%9C%EC%9E%91%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80.html"><![CDATA[<h1 id="목차">목차</h1>
<hr />

<ul>
  <li><a href="#에러-분석">에러 분석</a></li>
  <li><a href="#reactcreateelement">React.createElement()</a></li>
  <li><a href="#babel을-통한-jsx문법-변환">babel을 통한 JSX문법 변환</a>
    <ul>
      <li><a href="#번외-jsx없이-엘리먼트-만들기-createelement만으로-엘리먼트-만들기">번외) JSX없이 엘리먼트 만들기 (createElement만으로 엘리먼트 만들기)</a></li>
    </ul>
  </li>
  <li><a href="#대문자만-가능한-이유">대문자만 가능한 이유</a></li>
  <li><a href="#결론">결론</a></li>
</ul>

<h1 id="에러-분석">에러 분석</h1>
<hr />

<p>리액트 컴포넌트를 사용할 때에는 무조건 대문자로 시작해야 한다. <code class="language-plaintext highlighter-rouge">&lt;bCompo&gt;</code>라는 소문자 컴포넌트를 이용을 하면 브라우저에 이런 에러가 뜬다.</p>

<blockquote>
  <p><strong>에러</strong> <br />
The tag <code class="language-plaintext highlighter-rouge">&lt;bCompo&gt;</code> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.</p>
</blockquote>

<blockquote>
  <p><strong>해석</strong> <br />
<code class="language-plaintext highlighter-rouge">&lt;bCompo&gt;</code>는 이 브라우저에서 인식되지 않습니다. React 구성 요소를 렌더링하려는 경우 이름을 대문자로 시작하세요.</p>
</blockquote>

<p>리액트에서도 친절하게 대문자를 사용하라고 한다. 왜 대문자로 사용해야 할까? 그것을 알려면 리액트 JSX문법의 원리를 알아야 한다.</p>

<h1 id="reactcreateelement">React.createElement()</h1>
<hr />

<p>리액트 공식문서에서 <a href="https://ko.react.dev/reference/react/createElement">createElement</a>를 살펴볼수 있다. 우리가 흔히 사용하는 JSX문법은 <a href="https://babeljs.io/">babel</a>에 의해 react가 읽을 수 있는 코드인 createElement()로 변환된다.</p>

<h1 id="babel을-통한-jsx문법-변환">babel을 통한 JSX문법 변환</h1>
<hr />

<p>아래의 코드는 우리가 흔히 사용하는 JSX문법을 사용한 리액트 코드이다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">ACompo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return </span><span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>ACompo<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">BCompo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return </span><span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>BCompo<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">CCompo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return </span><span class="p">(</span>
    <span class="p">&lt;&gt;</span>
      <span class="p">&lt;</span><span class="nc">ACompo</span><span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nt">bcompo</span><span class="p">/&gt;</span>
    <span class="p">&lt;/&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>위의 코드는 babel의 <code class="language-plaintext highlighter-rouge">@babel-plugin-transform-react.jsx</code> 플러그인으로 인해 아래와 같은 코드로 변환된다.</p>

<h2 id="변환-후-코드">변환 후 코드</h2>
<hr />

<p><img src="/public/img/jsx-after-babel.png" alt="babel로 변환 후의 코드" width="700px" height="600px" /></p>

<p>위의 코드에서 <code class="language-plaintext highlighter-rouge">/*#__PURE__*/_jsx</code>는 <code class="language-plaintext highlighter-rouge">React.createElement</code>로 생각하면 된다.</p>

<blockquote>
  <p>babel의 <a href="https://babeljs.io/repl#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&amp;build=&amp;builtIns=false&amp;corejs=3.21&amp;spec=false&amp;loose=false&amp;code_lz=Q&amp;debug=false&amp;forceAllTransforms=false&amp;modules=false&amp;shippedProposals=false&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=env%2Creact&amp;prettier=false&amp;targets=&amp;version=7.25.6&amp;externalPlugins=&amp;assumptions=%7B%7D">Try it out</a>에서 직접 코드를 입력하여 확인해 볼 수 있다.</p>
</blockquote>

<h2 id="번외-jsx없이-엘리먼트-만들기-createelement만으로-엘리먼트-만들기">번외) JSX없이 엘리먼트 만들기 (createElement만으로 엘리먼트 만들기)</h2>

<p>그렇다면 번외로 처음부터 <code class="language-plaintext highlighter-rouge">createElement</code>로 작성해도 잘 동작할까?</p>

<p><img src="/public/img/creating-an-element-without-JSX-code.png" alt="JSX 없이 작성된 코드" height="500px" width="500px" />
<img src="/public/img/creating-an-element-without-JSX-result.png" alt="JSX 없이 작성된 코드 결과" height="300x" width="300px" /></p>

<p>위의 그림과 같이 당연히(?) 잘 나오는 것을 볼 수 있다.
그 이유는 위에서 말했듯이 우리가 작성한 <code class="language-plaintext highlighter-rouge">JSX문법</code>은 결국 <code class="language-plaintext highlighter-rouge">createElement</code>로 변환하여 사용되기 때문이다.</p>

<h1 id="대문자만-가능한-이유">대문자만 가능한 이유</h1>
<hr />

<p>그렇다면 본론으로 돌아와서 리액트 컴포넌트가 대문자만 사용 가능한 이유는 HTML태그와 컴포넌트를 분리하기 위해서 이다. 위의 변환 후 코드를 다시 살펴보자.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">/*#__PURE__*/_jsx</code>는 <code class="language-plaintext highlighter-rouge">createElement</code>로 바꾸었다.</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">ACompo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">div</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">children</span><span class="p">:</span> <span class="nf">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">p</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">children</span><span class="p">:</span> <span class="dl">"</span><span class="s2">ACompo</span><span class="dl">"</span>
    <span class="p">})</span>
  <span class="p">});</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">BCompo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">div</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">children</span><span class="p">:</span> <span class="nf">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">p</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">children</span><span class="p">:</span> <span class="dl">"</span><span class="s2">BCompo</span><span class="dl">"</span>
    <span class="p">})</span>
  <span class="p">});</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">CCompo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">createElements</span><span class="p">(</span><span class="nx">_Fragment</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">children</span><span class="p">:</span> <span class="p">[</span><span class="nf">createElement</span><span class="p">(</span><span class="nx">ACompo</span><span class="p">,</span> <span class="p">{}),</span> <span class="nf">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">bcompo</span><span class="dl">"</span><span class="p">,</span> <span class="p">{})]</span>
  <span class="p">});</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">CCompo</code>의 <code class="language-plaintext highlighter-rouge">children</code> 내부를 살펴보자.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nf">createElement</span><span class="p">(</span><span class="nx">ACompo</span><span class="p">,</span> <span class="p">{}),</span> <span class="nf">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">bcompo</span><span class="dl">"</span><span class="p">,</span> <span class="p">{})]</span>
</code></pre></div></div>
<p>createElement내부를 보면 대문자로 시작된 ACompo는 함수 그대로 들어가 있는데, bCompo는 문자열로 들어가있는 것을 볼 수 있다. 여기서 문자열로 변환된 곳이 또 있다. ACompo, BCompo의 내부도 “div”, 문자열로 들어가 있는 것을 볼 수 있다. 
소문자로 시작된 것은 컴포넌트로 보지않고 HTML의 tag로 인지하여 문자열로 들어간다. 그래서 bCompo뿐만 아니라 div도 문자열로 들어가 있는 것이다. 대문자로 해야 우리가 작성한 함수가 그대로 들어가 컴포넌트 그대로를 인지할 수 있다.</p>

<h1 id="결론">결론</h1>
<hr />

<p>babel은 JSX에서 대소문자로 컴포넌트와 HTML 태그를 구분하여 변환한다. 그래서 컴포넌트로 사용할 때에는 대문자로 사용해야 원하는 컴포넌트를 화면에 노출 될 수 있도록 해야한다.</p>]]></content><author><name></name></author><category term="React" /><summary type="html"><![CDATA[목차]]></summary></entry><entry><title type="html">Next.js의 env는 이중인격이다?!</title><link href="http://localhost:4000/next.js/2024/09/20/Next.js%EC%9D%98-env%EB%8A%94-%EC%9D%B4%EC%A4%91%EC%9D%B8%EA%B2%A9%EC%9D%B4%EB%8B%A4-!.html" rel="alternate" type="text/html" title="Next.js의 env는 이중인격이다?!" /><published>2024-09-20T15:23:00+09:00</published><updated>2024-09-20T15:23:00+09:00</updated><id>http://localhost:4000/next.js/2024/09/20/Next.js%EC%9D%98%20env%EB%8A%94%20%EC%9D%B4%EC%A4%91%EC%9D%B8%EA%B2%A9%EC%9D%B4%EB%8B%A4?!</id><content type="html" xml:base="http://localhost:4000/next.js/2024/09/20/Next.js%EC%9D%98-env%EB%8A%94-%EC%9D%B4%EC%A4%91%EC%9D%B8%EA%B2%A9%EC%9D%B4%EB%8B%A4-!.html"><![CDATA[<h1 id="목차">목차</h1>
<hr />

<ul>
  <li><a href="#문제-설명">문제 설명</a></li>
  <li><a href="#문제-분석">문제 분석</a></li>
  <li><a href="#문제-원인">문제 원인</a></li>
  <li><a href="#결론">결론</a></li>
</ul>

<h1 id="문제-설명">문제 설명</h1>
<hr />

<p>Next.js실습을 하고 있었다. 서버 주소를 <code class="language-plaintext highlighter-rouge">.env</code>로 관리하고 있었고, 렌더링 방식을 SSG로 변경하고 있었다. SSG로 변경하고 서버 요청 시 에러가 발생했다.</p>

<p><img src="/public/img/nextjs-env-error.png" alt="SSG로 변경 후 network 에러 사진" width="500px" height="220px" /></p>

<h1 id="문제-분석">문제 분석</h1>
<hr />

<p>에러 사진을 자세히 보면 <code class="language-plaintext highlighter-rouge">요청 URL</code>에 <code class="language-plaintext highlighter-rouge">undefined</code>가 있는 것을 볼 수 있다. 
이전과 달라진 점은 렌더링 방식뿐이다. SSG를 간단히 설명하면 서버에서 이미 렌더된 페이지를 보내주는 방식이다. 고민 끝에 .env가 서버에서는 인지하지 못할 수도 있다는 생각이 들었다.</p>

<h1 id="문제-원인">문제 원인</h1>
<hr />

<p>나의 생각이 맞았다. 나의 <code class="language-plaintext highlighter-rouge">.env</code>파일이다.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">NEXT_MOVIE_API_URL</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">http://localhost:12345/movie</span><span class="dl">"</span>
</code></pre></div></div>

<p>Next.js의 env는 <code class="language-plaintext highlighter-rouge">Private</code>와 <code class="language-plaintext highlighter-rouge">Public</code>으로 구분한다. 그래서 제목을 이렇게 지은 것이다.</p>

<hr />

<table>
  <thead>
    <tr>
      <th>종류</th>
      <th>설명</th>
      <th>예</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Public</code> 환경 변수</td>
      <td>클라이언트와 서버에서 모두 사용 가능한 변수</td>
      <td>NEXT_PUBLIC_XXX</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Private</code> 환경 변수</td>
      <td>서버 사이드에서만 사용 가능한 변수</td>
      <td>NEXT_XXX</td>
    </tr>
  </tbody>
</table>

<hr />

<p>위의 표처럼 나는 후자인 Private방식을 사용하고 있어서 서버에서 동작하는 SSG방식에서는 env 변수를 인지하지 못했던 것이다.</p>

<h1 id="결론">결론</h1>
<hr />

<p>아직 <code class="language-plaintext highlighter-rouge">Private</code>와 <code class="language-plaintext highlighter-rouge">Public</code>구분하여 사용할 이유를 찾기 못했다. 일단 <code class="language-plaintext highlighter-rouge">Public</code>으로 사용하여 문제가 없도록 하는게 좋을 것 같다.</p>]]></content><author><name></name></author><category term="Next.js" /><summary type="html"><![CDATA[목차]]></summary></entry><entry><title type="html">JavaScript의 변수는 껍데기 일뿐?</title><link href="http://localhost:4000/javascript/2024/07/31/JavaScript%EC%9D%98-%EB%B3%80%EC%88%98%EB%8A%94-%EA%BB%8D%EB%8D%B0%EA%B8%B0-%EC%9D%BC%EB%BF%90.html" rel="alternate" type="text/html" title="JavaScript의 변수는 껍데기 일뿐?" /><published>2024-07-31T21:12:00+09:00</published><updated>2024-07-31T21:12:00+09:00</updated><id>http://localhost:4000/javascript/2024/07/31/JavaScript%EC%9D%98%20%EB%B3%80%EC%88%98%EB%8A%94%20%EA%BB%8D%EB%8D%B0%EA%B8%B0%20%EC%9D%BC%EB%BF%90</id><content type="html" xml:base="http://localhost:4000/javascript/2024/07/31/JavaScript%EC%9D%98-%EB%B3%80%EC%88%98%EB%8A%94-%EA%BB%8D%EB%8D%B0%EA%B8%B0-%EC%9D%BC%EB%BF%90.html"><![CDATA[<h1 id="목차">목차</h1>
<ul>
  <li><a href="#흔한-변수에-대한-오해">흔한 변수에 대한 오해</a></li>
  <li><a href="#변수의-두-얼굴">변수의 두 얼굴</a></li>
  <li><a href="#메모리-공간의-이름-변수명">메모리 공간의 이름, 변수명</a></li>
  <li><a href="#데이터를-복붙하여-사용">데이터를 복붙하여 사용</a></li>
  <li><a href="#결론">결론</a></li>
</ul>

<h1 id="흔한-변수에-대한-오해">흔한 변수에 대한 오해</h1>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">홍길동</span><span class="dl">'</span>
</code></pre></div></div>

<p>위의 코드를 보면 우리는 <code class="language-plaintext highlighter-rouge">name</code>이라는 변수에 <code class="language-plaintext highlighter-rouge">홍길동</code>이라는 데이터가 들어갈 것이라고 생각한다.<br />
하지만 디테일하게 말하면 틀린 말이다.</p>

<h1 id="변수의-두-얼굴">변수의 두 얼굴</h1>
<p>변수의 의미는 <code class="language-plaintext highlighter-rouge">변할 수 있는 수</code>이다. 여기서 말하는 <code class="language-plaintext highlighter-rouge">수</code>는 <code class="language-plaintext highlighter-rouge">데이터</code>를 뜻한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">홍길동</span><span class="dl">'</span>
</code></pre></div></div>

<p>위의 코드에서 <code class="language-plaintext highlighter-rouge">name</code>은 큰 의미에서 <code class="language-plaintext highlighter-rouge">변수</code>이지만, 디데일하게 얘기하면 <code class="language-plaintext highlighter-rouge">식별자</code>, <code class="language-plaintext highlighter-rouge">변수명</code>이다. <br />
사실 우리가 흔히 말하는 변수(<code class="language-plaintext highlighter-rouge">name</code>)는 <code class="language-plaintext highlighter-rouge">하나의 공간</code>을 뜻한다. 그 공간에 이름을 붙여준 것이 <code class="language-plaintext highlighter-rouge">식별자</code>, <code class="language-plaintext highlighter-rouge">변수명</code>인 것이다.</p>

<p>여기서 말하는 <code class="language-plaintext highlighter-rouge">하나의 공간</code>은 <code class="language-plaintext highlighter-rouge">메모리</code>를 뜻한다. 모든 <code class="language-plaintext highlighter-rouge">수(데이터)</code>는 <code class="language-plaintext highlighter-rouge">메모리</code>에 올라간다. 그 <code class="language-plaintext highlighter-rouge">메모리 주소를 이름으로 매핑</code>한 것이 <code class="language-plaintext highlighter-rouge">식별자</code>, <code class="language-plaintext highlighter-rouge">변수명</code>인 것이다.</p>

<h1 id="메모리-공간의-이름-변수명">메모리 공간의 이름, 변수명</h1>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">홍길동</span><span class="dl">'</span>
</code></pre></div></div>

<p>위의 코드에서 <code class="language-plaintext highlighter-rouge">name</code>은 1001이라는 주소(임의의 메모리 주소)에 할당된다. 1001의 데이터는 변수명(식별자)인 <code class="language-plaintext highlighter-rouge">name</code>이 들어가고 값으로 5001이라는 <code class="language-plaintext highlighter-rouge">데이터 할당 메모리 주소 값</code>이 들어간다.</p>

<hr />

<table>
  <thead>
    <tr>
      <th>메모리 주소</th>
      <th>데이터</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1002</td>
      <td>이름: name, 값: 5001</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>5001</td>
      <td>‘홍길동’</td>
    </tr>
  </tbody>
</table>

<hr />

<h1 id="데이터를-복붙하여-사용">데이터를 복붙하여 사용</h1>
<p>위의 내용과 표처럼 메모리 주소의 이름을 붙여준 것이 변수명이고, 값은 또 다른 메모리 주소를 갖는다.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">personA</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">홍길동</span><span class="dl">'</span>
<span class="kd">const</span> <span class="nx">personB</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">홍길동</span><span class="dl">'</span>
</code></pre></div></div>

<p>만약 위와 같이 동명이인을 코드로 표현하면 우리는 흔히 <code class="language-plaintext highlighter-rouge">홍길동</code>이 두번 만들어져서 대입되는 줄 안다. 하지만 그것은 틀렸다.</p>

<hr />

<table>
  <thead>
    <tr>
      <th>메모리 주소</th>
      <th>데이터</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1002</td>
      <td>이름: personA, 값: 5001</td>
    </tr>
    <tr>
      <td>1003</td>
      <td>이름: personB, 값: 5001</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>5001</td>
      <td>‘홍길동’</td>
    </tr>
  </tbody>
</table>

<hr />

<p>위의 표와 같이 값이 복사되는 것이 아닌 메모리 주소 값이 복사되는 것이여서 결국 <code class="language-plaintext highlighter-rouge">홍길동</code>이라는 데이터는 하나이다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">personA</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">홍길동</span><span class="dl">'</span>
<span class="kd">let</span> <span class="nx">personB</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">홍길동</span><span class="dl">'</span>

<span class="nx">personA</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">이순신</span><span class="dl">'</span>
</code></pre></div></div>
<p>만약 위에 같이 똑같았던 두 개의 변수 중 하나의 값이 변경하면 어떻게 될까?</p>

<hr />

<table>
  <thead>
    <tr>
      <th>메모리 주소</th>
      <th>데이터</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1002</td>
      <td>이름: personA, 값: 5002</td>
    </tr>
    <tr>
      <td>1003</td>
      <td>이름: personB, 값: 5001</td>
    </tr>
    <tr>
      <td>…</td>
      <td>…</td>
    </tr>
    <tr>
      <td>5001</td>
      <td>‘홍길동’</td>
    </tr>
    <tr>
      <td>5002</td>
      <td>‘이순신’</td>
    </tr>
  </tbody>
</table>

<hr />

<p>새로운 데이터 영역의 메모리에 <code class="language-plaintext highlighter-rouge">이순신</code>을 만들어서 대입 후 <code class="language-plaintext highlighter-rouge">personA</code>라는 이름을 가진 메모리 주소의 값에 넣어준다.</p>

<h1 id="결론">결론</h1>
<blockquote>
  <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">홍길동</span><span class="dl">'</span>
</code></pre></div>  </div>
  <p>위의 코드를 보면 우리는 <code class="language-plaintext highlighter-rouge">name</code>이라는 변수에 <code class="language-plaintext highlighter-rouge">홍길동</code>이라는 데이터가 들어갈 것이라고 생각한다.<br />
하지만 디테일하게 말하면 틀린 말이다.</p>
</blockquote>

<p>처음 했던 말을 좀 더 정확하게 얘기하면 위의 코드는 <code class="language-plaintext highlighter-rouge">메모리 주소의 이름을 name이라고 정하고, 그 이름의 데이터 값에 다른 메모리 주소에 '홍길동'이라는 값을 만들고 그 메모리 주소값을 대입하는 것</code>이 맞다.</p>]]></content><author><name></name></author><category term="JavaScript" /><summary type="html"><![CDATA[목차 흔한 변수에 대한 오해 변수의 두 얼굴 메모리 공간의 이름, 변수명 데이터를 복붙하여 사용 결론]]></summary></entry></feed>