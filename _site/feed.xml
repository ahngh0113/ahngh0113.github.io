<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-10-03T22:12:47+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">안기환</title><subtitle>프론트엔드 개발자</subtitle><entry><title type="html">Nest.js에서 데이터 캐시하기 with App-Router</title><link href="http://localhost:4000/next.js/2024/10/03/Nest.js%EC%97%90%EC%84%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%BA%90%EC%8B%9C%ED%95%98%EA%B8%B0-with-App-Router.html" rel="alternate" type="text/html" title="Nest.js에서 데이터 캐시하기 with App-Router" /><published>2024-10-03T21:12:45+09:00</published><updated>2024-10-03T21:12:45+09:00</updated><id>http://localhost:4000/next.js/2024/10/03/Nest.js%EC%97%90%EC%84%9C%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EC%BA%90%EC%8B%9C%ED%95%98%EA%B8%B0%20with%20App-Router</id><content type="html" xml:base="http://localhost:4000/next.js/2024/10/03/Nest.js%EC%97%90%EC%84%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%BA%90%EC%8B%9C%ED%95%98%EA%B8%B0-with-App-Router.html"><![CDATA[<h1 id="목차">목차</h1>
<hr />

<ul>
  <li><a href="#일반-fetch-vs-nextjs-fetch">일반 fetch() vs Next.js fetch()</a></li>
  <li><a href="#nextjs의-fetch-옵션">Next.js의 fetch() 옵션</a>
    <ul>
      <li><a href="#cache할-경우">cache할 경우</a></li>
      <li><a href="#cache하지-않는-경우">cache하지 않는 경우</a></li>
      <li><a href="#특정-시간-이후에-다시-fetch">특정 시간 이후에 다시 fetch</a></li>
      <li><a href="#특정-요청이-들어-왔을-때에-다시-fetch">특정 요청이 들어 왔을 때에 다시 fetch</a></li>
    </ul>
  </li>
</ul>

<h1 id="일반-fetch-vs-nextjs-fetch">일반 fetch() vs Next.js fetch()</h1>
<hr />

<p>Next.js에서는 fetch()함수로 데이터를 통신하는 것을 권장한다. 이 이유는 Next.js 기존 fetch의 확장판으로 커스텀 했기 때문이다. 일반 fetch와는 다르게 Next.js의 fetch()는 캐싱 및 성능 최적화 기능을 더해준다. 어떠한 기능이 있는지 살펴보자.</p>

<h1 id="nextjs에서-fetch를-logging하는-법">Next.js에서 fetch를 logging하는 법</h1>
<hr />

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** @type {import('next').NextConfig} */</span>
<span class="kd">const</span> <span class="nx">nextConfig</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">logging</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">fetches</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">fullUrl</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">nextConfig</span><span class="p">;</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">next.config.mjs</code>파일에 위와 같이 <code class="language-plaintext highlighter-rouge">logging</code>옵션을 추가해 주면 터미널에서 확인 할 수 있다.</p>

<h1 id="nextjs의-fetch-옵션">Next.js의 fetch() 옵션</h1>
<hr />

<h2 id="cache할-경우">cache할 경우</h2>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://api.vercel.app/blog</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">cache</span><span class="p">:</span> <span class="dl">'</span><span class="s1">force-cach</span><span class="dl">'</span> <span class="p">})</span>
</code></pre></div></div>
<p>요청의 결과를 저장하는 옵션이다. 첫 요청을 제외하고는 위와 같이 fetch()가 있어도 통신을 하지 않고 저장된 데이터 값을 가져온다. 거의 변하지 않는 데이터를 렌더링할 때 사용하면 좋은 옵션이다.</p>

<h2 id="cache하지-않는-경우">cache하지 않는 경우</h2>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://api.vercel.app/blog</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">cache</span><span class="p">:</span> <span class="dl">'</span><span class="s1">no-store</span><span class="dl">'</span> <span class="p">})</span>
</code></pre></div></div>
<p>요청의 결과를 저장하지 않는 옵션이다. <code class="language-plaintext highlighter-rouge">{ cache: 'no-store' }</code>를 두번째 인자에 넣어주면 된다. 이러면 페이지 진입할 때마다 fetch()를 진행한다. 실시간성 데이터가 렌더링 될 때 사용하면 적합한 옵션이다.<br />
옵션의 기본 값으로 옵션에 아무런 설정을 하지 않으면 <code class="language-plaintext highlighter-rouge">{ cache: 'no-store' }</code>처럼 동작한다.<br />
<strong>(* v15이전 버전은 캐싱하는 것을 기본으로 설정되었으나 사용자가의 불만이 많아 v15부터는 캐싱하지 않는 것이 default이다.)</strong></p>

<h2 id="특정-시간-이후에-다시-fetch">특정 시간 이후에 다시 fetch</h2>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://api.vercel.app/blog</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">next</span><span class="p">:</span> <span class="p">{</span> <span class="na">revalidate</span><span class="p">:</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">})</span>
</code></pre></div></div>

<p>Page-Router의 ISR과 같이 특정 시간을 주기로 캐시를 업데이트 하는 방식이다. 가끔 데이터가 업데이트 될 때 사용하면 적합한 옵션이다. revalidate안에 들어갈 숫자는 초단위이다.</p>

<h2 id="특정-요청이-들어-왔을-때에-다시-fetch">특정 요청이 들어 왔을 때에 다시 fetch</h2>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://api.vercel.app/blog</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">next</span><span class="p">:</span> <span class="p">{</span> <span class="na">tags</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">]}})</span>
</code></pre></div></div>
<p>Page-Router의 On-Demand ISR과 비슷한 방식이다. 처음 요청 시 데이터를 캐시하고, 특정 요청 시 있을 때 갈아끼우는 형식이다. 가끔 변하는 데이터를 핸들링할 때 편리한 옵션이다.</p>]]></content><author><name></name></author><category term="Next.js" /><summary type="html"><![CDATA[목차]]></summary></entry><entry><title type="html">리액트 컴포넌트는 왜 대문자로 시작해야 하는가?</title><link href="http://localhost:4000/react/2024/09/30/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%8A%94-%EC%99%9C-%EB%8C%80%EB%AC%B8%EC%9E%90%EB%A1%9C-%EC%8B%9C%EC%9E%91%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80.html" rel="alternate" type="text/html" title="리액트 컴포넌트는 왜 대문자로 시작해야 하는가?" /><published>2024-09-30T21:23:45+09:00</published><updated>2024-09-30T21:23:45+09:00</updated><id>http://localhost:4000/react/2024/09/30/%EB%A6%AC%EC%95%A1%ED%8A%B8%20%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%8A%94%20%EC%99%9C%20%EB%8C%80%EB%AC%B8%EC%9E%90%EB%A1%9C%20%EC%8B%9C%EC%9E%91%ED%95%B4%EC%95%BC%20%ED%95%98%EB%8A%94%EA%B0%80</id><content type="html" xml:base="http://localhost:4000/react/2024/09/30/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%8A%94-%EC%99%9C-%EB%8C%80%EB%AC%B8%EC%9E%90%EB%A1%9C-%EC%8B%9C%EC%9E%91%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80.html"><![CDATA[<h1 id="목차">목차</h1>
<hr />

<ul>
  <li><a href="#에러-분석">에러 분석</a></li>
  <li><a href="#reactcreateelement">React.createElement()</a></li>
  <li><a href="#babel을-통한-jsx문법-변환">babel을 통한 JSX문법 변환</a>
    <ul>
      <li><a href="#번외-jsx없이-엘리먼트-만들기-createelement만으로-엘리먼트-만들기">번외) JSX없이 엘리먼트 만들기 (createElement만으로 엘리먼트 만들기)</a></li>
    </ul>
  </li>
  <li><a href="#대문자만-가능한-이유">대문자만 가능한 이유</a></li>
  <li><a href="#결론">결론</a></li>
</ul>

<h1 id="에러-분석">에러 분석</h1>
<hr />

<p>리액트 컴포넌트를 사용할 때에는 무조건 대문자로 시작해야 한다. <code class="language-plaintext highlighter-rouge">&lt;bCompo&gt;</code>라는 소문자 컴포넌트를 이용을 하면 브라우저에 이런 에러가 뜬다.</p>

<blockquote>
  <p><strong>에러</strong> <br />
The tag <code class="language-plaintext highlighter-rouge">&lt;bCompo&gt;</code> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.</p>
</blockquote>

<blockquote>
  <p><strong>해석</strong> <br />
<code class="language-plaintext highlighter-rouge">&lt;bCompo&gt;</code>는 이 브라우저에서 인식되지 않습니다. React 구성 요소를 렌더링하려는 경우 이름을 대문자로 시작하세요.</p>
</blockquote>

<p>리액트에서도 친절하게 대문자를 사용하라고 한다. 왜 대문자로 사용해야 할까? 그것을 알려면 리액트 JSX문법의 원리를 알아야 한다.</p>

<h1 id="reactcreateelement">React.createElement()</h1>
<hr />

<p>리액트 공식문서에서 <a href="https://ko.react.dev/reference/react/createElement">createElement</a>를 살펴볼수 있다. 우리가 흔히 사용하는 JSX문법은 <a href="https://babeljs.io/">babel</a>에 의해 react가 읽을 수 있는 코드인 createElement()로 변환된다.</p>

<h1 id="babel을-통한-jsx문법-변환">babel을 통한 JSX문법 변환</h1>
<hr />

<p>아래의 코드는 우리가 흔히 사용하는 JSX문법을 사용한 리액트 코드이다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">ACompo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return </span><span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>ACompo<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">BCompo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return </span><span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>BCompo<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">CCompo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return </span><span class="p">(</span>
    <span class="p">&lt;&gt;</span>
      <span class="p">&lt;</span><span class="nc">ACompo</span><span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nt">bcompo</span><span class="p">/&gt;</span>
    <span class="p">&lt;/&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>위의 코드는 babel의 <code class="language-plaintext highlighter-rouge">@babel-plugin-transform-react.jsx</code> 플러그인으로 인해 아래와 같은 코드로 변환된다.</p>

<h2 id="변환-후-코드">변환 후 코드</h2>
<hr />

<p><img src="/public/img/jsx-after-babel.png" alt="babel로 변환 후의 코드" width="700px" height="600px" /></p>

<p>위의 코드에서 <code class="language-plaintext highlighter-rouge">/*#__PURE__*/_jsx</code>는 <code class="language-plaintext highlighter-rouge">React.createElement</code>로 생각하면 된다.</p>

<blockquote>
  <p>babel의 <a href="https://babeljs.io/repl#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&amp;build=&amp;builtIns=false&amp;corejs=3.21&amp;spec=false&amp;loose=false&amp;code_lz=Q&amp;debug=false&amp;forceAllTransforms=false&amp;modules=false&amp;shippedProposals=false&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=env%2Creact&amp;prettier=false&amp;targets=&amp;version=7.25.6&amp;externalPlugins=&amp;assumptions=%7B%7D">Try it out</a>에서 직접 코드를 입력하여 확인해 볼 수 있다.</p>
</blockquote>

<h2 id="번외-jsx없이-엘리먼트-만들기-createelement만으로-엘리먼트-만들기">번외) JSX없이 엘리먼트 만들기 (createElement만으로 엘리먼트 만들기)</h2>

<p>그렇다면 번외로 처음부터 <code class="language-plaintext highlighter-rouge">createElement</code>로 작성해도 잘 동작할까?</p>

<p><img src="/public/img/creating-an-element-without-JSX-code.png" alt="JSX 없이 작성된 코드" height="500px" width="500px" />
<img src="/public/img/creating-an-element-without-JSX-result.png" alt="JSX 없이 작성된 코드 결과" height="300x" width="300px" /></p>

<p>위의 그림과 같이 당연히(?) 잘 나오는 것을 볼 수 있다.
그 이유는 위에서 말했듯이 우리가 작성한 <code class="language-plaintext highlighter-rouge">JSX문법</code>은 결국 <code class="language-plaintext highlighter-rouge">createElement</code>로 변환하여 사용되기 때문이다.</p>

<h1 id="대문자만-가능한-이유">대문자만 가능한 이유</h1>
<hr />

<p>그렇다면 본론으로 돌아와서 리액트 컴포넌트가 대문자만 사용 가능한 이유는 HTML태그와 컴포넌트를 분리하기 위해서 이다. 위의 변환 후 코드를 다시 살펴보자.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">/*#__PURE__*/_jsx</code>는 <code class="language-plaintext highlighter-rouge">createElement</code>로 바꾸었다.</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">ACompo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">div</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">children</span><span class="p">:</span> <span class="nf">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">p</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">children</span><span class="p">:</span> <span class="dl">"</span><span class="s2">ACompo</span><span class="dl">"</span>
    <span class="p">})</span>
  <span class="p">});</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">BCompo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">div</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">children</span><span class="p">:</span> <span class="nf">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">p</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">children</span><span class="p">:</span> <span class="dl">"</span><span class="s2">BCompo</span><span class="dl">"</span>
    <span class="p">})</span>
  <span class="p">});</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">CCompo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">createElements</span><span class="p">(</span><span class="nx">_Fragment</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">children</span><span class="p">:</span> <span class="p">[</span><span class="nf">createElement</span><span class="p">(</span><span class="nx">ACompo</span><span class="p">,</span> <span class="p">{}),</span> <span class="nf">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">bcompo</span><span class="dl">"</span><span class="p">,</span> <span class="p">{})]</span>
  <span class="p">});</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">CCompo</code>의 <code class="language-plaintext highlighter-rouge">children</code> 내부를 살펴보자.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nf">createElement</span><span class="p">(</span><span class="nx">ACompo</span><span class="p">,</span> <span class="p">{}),</span> <span class="nf">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">bcompo</span><span class="dl">"</span><span class="p">,</span> <span class="p">{})]</span>
</code></pre></div></div>
<p>createElement내부를 보면 대문자로 시작된 ACompo는 함수 그대로 들어가 있는데, bCompo는 문자열로 들어가있는 것을 볼 수 있다. 여기서 문자열로 변환된 곳이 또 있다. ACompo, BCompo의 내부도 “div”, 문자열로 들어가 있는 것을 볼 수 있다. 
소문자로 시작된 것은 컴포넌트로 보지않고 HTML의 tag로 인지하여 문자열로 들어간다. 그래서 bCompo뿐만 아니라 div도 문자열로 들어가 있는 것이다. 대문자로 해야 우리가 작성한 함수가 그대로 들어가 컴포넌트 그대로를 인지할 수 있다.</p>

<h1 id="결론">결론</h1>
<hr />

<p>babel은 JSX에서 대소문자로 컴포넌트와 HTML 태그를 구분하여 변환한다. 그래서 컴포넌트로 사용할 때에는 대문자로 사용해야 원하는 컴포넌트를 화면에 노출 될 수 있도록 해야한다.</p>]]></content><author><name></name></author><category term="React" /><summary type="html"><![CDATA[목차]]></summary></entry><entry><title type="html">Next.js의 env는 이중인격이다?!</title><link href="http://localhost:4000/next.js/2024/09/20/Next.js%EC%9D%98-env%EB%8A%94-%EC%9D%B4%EC%A4%91%EC%9D%B8%EA%B2%A9%EC%9D%B4%EB%8B%A4-!.html" rel="alternate" type="text/html" title="Next.js의 env는 이중인격이다?!" /><published>2024-09-20T15:23:00+09:00</published><updated>2024-09-20T15:23:00+09:00</updated><id>http://localhost:4000/next.js/2024/09/20/Next.js%EC%9D%98%20env%EB%8A%94%20%EC%9D%B4%EC%A4%91%EC%9D%B8%EA%B2%A9%EC%9D%B4%EB%8B%A4?!</id><content type="html" xml:base="http://localhost:4000/next.js/2024/09/20/Next.js%EC%9D%98-env%EB%8A%94-%EC%9D%B4%EC%A4%91%EC%9D%B8%EA%B2%A9%EC%9D%B4%EB%8B%A4-!.html"><![CDATA[<h1 id="목차">목차</h1>
<hr />

<ul>
  <li><a href="#문제-설명">문제 설명</a></li>
  <li><a href="#문제-분석">문제 분석</a></li>
  <li><a href="#문제-원인">문제 원인</a></li>
  <li><a href="#결론">결론</a></li>
</ul>

<h1 id="문제-설명">문제 설명</h1>
<hr />

<p>Next.js실습을 하고 있었다. 서버 주소를 <code class="language-plaintext highlighter-rouge">.env</code>로 관리하고 있었고, 렌더링 방식을 SSG로 변경하고 있었다. SSG로 변경하고 서버 요청 시 에러가 발생했다.</p>

<p><img src="/public/img/nextjs-env-error.png" alt="SSG로 변경 후 network 에러 사진" width="500px" height="220px" /></p>

<h1 id="문제-분석">문제 분석</h1>
<hr />

<p>에러 사진을 자세히 보면 <code class="language-plaintext highlighter-rouge">요청 URL</code>에 <code class="language-plaintext highlighter-rouge">undefined</code>가 있는 것을 볼 수 있다. 
이전과 달라진 점은 렌더링 방식뿐이다. SSG를 간단히 설명하면 서버에서 이미 렌더된 페이지를 보내주는 방식이다. 고민 끝에 .env가 서버에서는 인지하지 못할 수도 있다는 생각이 들었다.</p>

<h1 id="문제-원인">문제 원인</h1>
<hr />

<p>나의 생각이 맞았다. 나의 <code class="language-plaintext highlighter-rouge">.env</code>파일이다.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">NEXT_MOVIE_API_URL</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">http://localhost:12345/movie</span><span class="dl">"</span>
</code></pre></div></div>

<p>Next.js의 env는 <code class="language-plaintext highlighter-rouge">Private</code>와 <code class="language-plaintext highlighter-rouge">Public</code>으로 구분한다. 그래서 제목을 이렇게 지은 것이다.</p>

<hr />

<table>
  <thead>
    <tr>
      <th>종류</th>
      <th>설명</th>
      <th>예</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Public</code> 환경 변수</td>
      <td>클라이언트와 서버에서 모두 사용 가능한 변수</td>
      <td>NEXT_PUBLIC_XXX</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Private</code> 환경 변수</td>
      <td>서버 사이드에서만 사용 가능한 변수</td>
      <td>NEXT_XXX</td>
    </tr>
  </tbody>
</table>

<hr />

<p>위의 표처럼 나는 후자인 Private방식을 사용하고 있어서 서버에서 동작하는 SSG방식에서는 env 변수를 인지하지 못했던 것이다.</p>

<h1 id="결론">결론</h1>
<hr />

<p>아직 <code class="language-plaintext highlighter-rouge">Private</code>와 <code class="language-plaintext highlighter-rouge">Public</code>구분하여 사용할 이유를 찾기 못했다. 일단 <code class="language-plaintext highlighter-rouge">Public</code>으로 사용하여 문제가 없도록 하는게 좋을 것 같다.</p>]]></content><author><name></name></author><category term="Next.js" /><summary type="html"><![CDATA[목차]]></summary></entry></feed>